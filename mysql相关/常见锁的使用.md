#### 锁的分类

从数据库的管理角度区分共享锁和排他锁 ，即读锁和写锁

#### 共享锁 

也叫读锁或者S锁，共享锁的资源可以被其他用户读取但是不能修改，在select时会将对象进行共享锁锁定，读取完毕时就会释放锁，就可以保证数据在读取时不会被修改

```
lock table xxx read;
unlock table
```

对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即共享锁可多个共存），但无法修改,要想修改就必须等所有共享锁都释放完之后

```
select * from table lock in share mode
```

注意：

共享锁保证大家可以一起读，但只能一个人写

#### 排他锁 

排他锁也叫独占锁，写锁或者X锁，锁定的数据只允许进行锁定的事务使用，其他事务无法对已锁定的数据进行查询和操作

```
lock table xxx write;
unlock table;
```

程序上可以将锁划分为乐观锁和悲观锁

- 乐观锁

乐观锁认为对同一数据的并发操作不会总发生，持乐观态度，属于小概率事件不需要每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现

主要通过版本号机制实现，数据表新增version字段,第一次读取的时候会获取version的值，然后对数据进行更新和删除操作时，会进行版本号的比对，如果版本号一致则修改数据并将版本号+1，如果版本号不一致则修改失败

```
SELECT data,version AS old_version FROM …;

UPDATE SET data = new_data, version = old_version+1 WHERE version = old_version
```

我们还可以使用PHP文件乐观锁，在处理下单请求的时候用flock锁定一个文件，如果锁定失败说明有其他订单正在处理，此时要么等待要么直接提示用户"服务器繁忙"
```
<?php  
$fp = fopen("lock.txt", "w+");   
if (flock($fp, LOCK_NB | LOCK_EX)) {  
    echo 'do something';  
    @flock($fp, LOCK_UN);  
} else {  
    echo '系统繁忙';  
}  
@fclose($fp);  
 ```

- 悲观锁

对数据被其他的事务修改持保守态度，通过数据库自身的锁机制来实现，保证数据操作的排他性

对数据冲突持有悲观的态度认为肯定会冲突，那么在每次数据读取的时候将数据锁住，之后所有的操作读取操作都需要等待

通过常用的select … for update操作来实现悲观锁,当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图获取同一行数据则会发生排斥(需要等待行锁被释放)，因此达到锁的效果，锁会在当前事务结束时自动释放，因此必须在事务中使用

- 使用场景
```
两种锁都是为了解决并发情况下的写冲突,用哪种机制取决于使用的场景能否达到提高写效率的目的 

悲观锁是early lock，乐观锁是late lock。因此： 

1. 对于数据更新频繁的场合，悲观锁效率更高 

2. 对于数据更新不频繁的场合，乐观锁效率更高

两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适
```